# 内存管理
https://juejin.im/post/5efadf48f265da2304062e51#heading-8

[TOC]

### 虚拟内存
操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。

操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存


### 逻辑地址 虚拟地址 物理地址
程序所使用的地址，通常是没被段式内存管理映射的地址，称为逻辑地址；
通过段式内存管理映射的地址，称为线性地址，也叫虚拟地址；
### 块式管理、段式管理、页式管理、段页管理

#### 段式 
原理：段选择子和段内偏移量。
问题：碎片，交换效率低

#### 页式
原理: 页号 页内偏移。 虚拟页号通过页表转成物理页号
优点：解决了段式的缺点
缺点：页表大

#### 多级页表
局部性原理 
未用到的先不分配
64 位的系统，两级分页肯定不够了，就变成了四级目录
缺点： 转换多次

#### TLB 
我们就可以利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件，于是计算机科学家们，就在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB（Translation Lookaside Buffer） ，通常称为页表缓存、转址旁路缓存、快表等。

先查TLB 命中率高

#### 内存交换
磁盘 swap 空间实现内存交换
这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。
### 页面置换算法

### Linux 采取的是页式 （intel cpu 段页式）
Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。

### Linux 如何分布
进程内核空间和用户空间
每个虚拟内存中的内核地址，其实关联的都是相同的物理内存

### Memory Mapped Files（MMAP）

通过mmap，进程像读写硬盘一样读写内存（当然是虚拟机内存），也不必关心内存的大小有虚拟内存为我们兜底。

mmap其实是Linux中的一个函数。就是用来实现内存映射的。
Java NIO，它给我提供了一个mappedbytebuffer类可以用来实现内存映射

mmap()会返回一个指针ptr，它指向进程逻辑地址空间中的一个地址，这样以后，进程无需再调用read或write对文件进行读写，而只需要通过ptr就能够操作文件;

实现文件物理地址和进程虚拟地址的一一映射关系;

利用了缺页异常进行调页 经swap 交换回 磁盘
